<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>rise-data-rss test</title>

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../node_modules/sinon/pkg/sinon.js"></script>

    <script type="text/javascript">
      RisePlayerConfiguration = {
        isConfigured: () => true
      };
    </script>

    <script type="module" src="../src/rise-data-rss-config.js"></script>
    <script type="module" src="../src/rise-data-rss.js"></script>
  </head>
  <body>
    <test-fixture id="test-block">
      <template>
        <rise-data-rss></rise-data-rss>
      </template>
    </test-fixture>

    <script type="module">
      suite("rise-data-rss", () => {
        const sampleServerUrl = "https://feed-parser.risevision.com/";
        const sampleFeedUrl = "https://www.feedforall.com/sample.xml";
        const validRssJson = [
          {
            title: "Title 1",
            description: "Description 1",
            image: {
              url: "http://www.feedforall.com/ffalogo48x48.gif",
              title: "FeedForAll Sample Feed"
            }
          }
        ];
        const invalidRssJson = {
          Error: "An error has occurred"
        };
        let sandbox = sinon.createSandbox();
        let element;
        let fetchMixin, cacheMixin, riseElement, loggerMixin;

        setup(() => {
          element = fixture("test-block");

          // RiseDataRss => RiseFetchMixin => RiseCacheMixin => RiseElement => LoggerMixin
          fetchMixin = element.__proto__.__proto__;
          cacheMixin = element.__proto__.__proto__.__proto__;
          riseElement = element.__proto__.__proto__.__proto__.__proto__;
          loggerMixin = element.__proto__.__proto__.__proto__.__proto__.__proto__;

          sandbox.spy(riseElement, '_sendEvent');
          sandbox.stub(riseElement, '_setUptimeError');
          sandbox.stub(loggerMixin, "initLogger");
          sandbox.stub(loggerMixin, "log");
          sandbox.stub(window, "fetch");
        });

        teardown(()=>{
          sandbox.restore();
        });

        suite("properties", () => {
          test("should not set feedurl", () => {
            assert.notOk(element.feedurl);
          });

          test("should set maxitems", () => {
            assert.equal(element.maxitems, 25);
          });
        });

        suite("ready", () => {
          let stub;

          setup(() => {
            stub = sandbox.stub(window, "addEventListener");
          });

          test("should listen for rise-components-ready and call init", () => {
            RisePlayerConfiguration.isConfigured = () => false;
            element.ready();

            assert.isTrue(stub.calledWith('rise-components-ready'));
          });

          test("should call _init() if RisePlayerConfiguration is configured", () => {
            RisePlayerConfiguration.isConfigured = () => true;
            sandbox.stub(element, '_init');

            element.ready();

            assert.isTrue(element._init.calledOnce);
            assert.isFalse(stub.calledOnce);
          });
        });

        suite("init", () => {
          test("should listen for 'start' event", () => {
            sandbox.stub(element, "addEventListener");
            element._init();
            assert.isTrue(element.addEventListener.calledWith("start"));
          });

          test("should raise 'configured' event", () => {
            sandbox.stub(element, "dispatchEvent");
            element._init();
            assert.equal(element.dispatchEvent.getCall(0).args[0].type, "configured");
          });
        });

        suite("'start' event", () => {
          test("should request data only after start has been called", done => {
            sandbox.stub(fetchMixin, "fetch");

            element.feedurl = "sampleFeedUrl";

            setTimeout(() => {
              assert.isFalse(fetchMixin.fetch.called);

              element.dispatchEvent(new CustomEvent("start"));

              setTimeout(() => {
                assert.isTrue(fetchMixin.fetch.called);
                done();
              });
            });
          });
        });

        suite("_processRssData", () => {
          setup(() => {
            sandbox.stub(element, "_loadFeedData");
            sandbox.stub(element, "_sendRssEvent");
          });

          test("should set feedData", () => {
            element._processRssData([{ title: "Title 1" }]);

            assert.equal(element.feedData.length, 1);
            assert.isTrue(element._sendRssEvent.calledOnce);
          });

          test("should set feedData again if data changed", () => {
            element._processRssData([{ title: "Title 1" }]);
            element._processRssData([{ title: "Title 2" }]);

            assert.equal(element.feedData.length, 1);
            assert.isTrue(element._sendRssEvent.calledTwice);
          });

          test("should set feedData again if max items has changed", () => {
            var data = [{ title: "Title 1" }, { title: "Title 2" }, { title: "Title 3" }];

            element.maxitems = 3;
            element._processRssData(data);
            element.maxitems = 2;
            element._processRssData(data);

            assert.equal(element.feedData.length, 2);
            assert.isTrue(element._sendRssEvent.calledTwice);
          });

          test("should not set feedData again if data has not changed", () => {
            element._processRssData([{ title: "Title 1" }]);
            element._processRssData([{ title: "Title 1" }]);

            assert.equal(element.feedData.length, 1);
            assert.isTrue(element._sendRssEvent.calledOnce);
          });
        });

        suite("_loadFeedData", () => {
          let response;

          setup(() => {
            sandbox.stub(cacheMixin, "putCache").resolves();

            element.dispatchEvent(new CustomEvent("start"));
          });

          test("should handle a valid response from cache", done => {
            sandbox.stub(cacheMixin, "getCache").resolves(new Response(JSON.stringify(validRssJson)));

            element.feedurl = sampleFeedUrl;

            setTimeout(() => {
              assert.isTrue(riseElement._setUptimeError.calledWith(false));
              assert.isFalse(window.fetch.called);

              // Should log the received data
              assert.equal(element.log.getCall(1).args[1], "data received");
              assert.deepEqual(element.log.getCall(1).args[2], { cached: true });
              // Should send a data-update event
              assert.equal(element._sendEvent.getCall(0).args[0], "data-update");
              assert.deepEqual(element._sendEvent.getCall(0).args[1], validRssJson);

              done();
            }, 30);
          });

          test("should handle a valid response from feed-parser", done => {
            sandbox.stub(cacheMixin, "getCache").rejects();
            window.fetch.resolves(new Response(JSON.stringify(validRssJson)));

            element.feedurl = sampleFeedUrl;

            setTimeout(() => {
              assert.isTrue(riseElement._setUptimeError.calledWith(false));

              assert.isTrue(window.fetch.called);
              assert.equal(window.fetch.args[0][0], sampleServerUrl + sampleFeedUrl);

              // Should log the received data
              assert.equal(element.log.getCall(1).args[1], "data received");
              assert.deepEqual(element.log.getCall(1).args[2], { cached: false });
              // Should log that it provided new data to the client
              assert.equal(element.log.getCall(2).args[1], "data provided");
              // Should send a data-update event
              assert.equal(element._sendEvent.getCall(0).args[0], "data-update");
              assert.deepEqual(element._sendEvent.getCall(0).args[1], validRssJson);

              done();
            }, 30);
          });

          test("should only return the first 15 valid items", done => {
            let largeRssJson = [...Array(100).keys()].map(idx => {
              return {
                title: "Title #: " + idx
              }
            });

            sandbox.stub(cacheMixin, "getCache").rejects();
            window.fetch.resolves(new Response(JSON.stringify(largeRssJson)));

            element.maxitems = 15;
            element.feedurl = sampleFeedUrl;

            setTimeout(() => {
              assert.isTrue(window.fetch.called);
              assert.equal(window.fetch.args[0][0], sampleServerUrl + sampleFeedUrl);

              setTimeout(() => {
                assert.isTrue(riseElement._setUptimeError.calledWith(false));

                // Should log the received data
                assert.equal(element.log.getCall(1).args[1], "data received");
                assert.deepEqual(element.log.getCall(1).args[2], { cached: false });
                // Should send a data-update event
                assert.equal(element._sendEvent.getCall(0).args[0], "data-update");
                assert.deepEqual(element._sendEvent.getCall(0).args[1], largeRssJson.slice(0, 15));

                done();
              }, 20);
            });
          });

          test("should handle an invalid response from feed-parser", done => {
            sandbox.stub(cacheMixin, "getCache").rejects();
            window.fetch.resolves(new Response(JSON.stringify(invalidRssJson)));

            element.feedurl = sampleFeedUrl;

            setTimeout(() => {
              assert.isTrue(window.fetch.called);
              assert.equal(window.fetch.args[0][0], sampleServerUrl + sampleFeedUrl);

              setTimeout(() => {
                assert.isTrue(riseElement._setUptimeError.calledWith(true));

                // Should log the received data
                assert.equal(element.log.getCall(1).args[1], "data received");
                assert.deepEqual(element.log.getCall(1).args[2], { cached: false });
                // Should log the error data
                assert.equal(element.log.getCall(2).args[1], "data error");
                assert.deepEqual(element.log.getCall(2).args[2], { error: invalidRssJson.Error });
                // Should send a data-error event
                assert.equal(element._sendEvent.getCall(0).args[0], "data-error");
                assert.deepEqual(element._sendEvent.getCall(0).args[1], { error: invalidRssJson.Error });

                done();
              }, 20);
            });
          });

          test("should handle failure to connect to feed-parser", done => {
            let errorMessage = "Failed to connect to feed-parser";

            sandbox.stub(cacheMixin, "getCache").rejects();
            sandbox.stub(fetchMixin, "_isOffline").resolves(false);
            sandbox.stub(fetchMixin, "_isMaxRetryAttempt").returns(true);

            window.fetch.rejects({ message: errorMessage });

            element.feedurl = sampleFeedUrl;

            setTimeout(() => {
              assert.isTrue(window.fetch.called);

              setTimeout(() => {
                assert.isTrue(riseElement._setUptimeError.calledWith(true));

                // Should log the request error data
                assert.equal(element.log.getCall(1).args[1], "request error");
                assert.deepEqual(element.log.getCall(1).args[2], { error: errorMessage });
                // Should send a request-error event
                assert.equal(element._sendEvent.getCall(0).args[0], "request-error");
                assert.deepEqual(element._sendEvent.getCall(0).args[1], { error: errorMessage });

                done();
              }, 20);
            });
          });

          test("should handle failure to connect to feed-parser and not log if offline", done => {
            let errorMessage = "Failed to connect to feed-parser";

            sandbox.stub(element, "_handleResponse");
            sandbox.stub(cacheMixin, "getCache").rejects();
            sandbox.stub(fetchMixin, "_isOffline").resolves(true);
            sandbox.stub(fetchMixin, "_isMaxRetryAttempt").returns(true);
            window.fetch.rejects({ message: errorMessage });

            element.feedurl = sampleFeedUrl;

            setTimeout(() => {
              assert.isTrue(window.fetch.called);

              setTimeout(() => {
                assert.isFalse(riseElement._setUptimeError.called);
                assert.isTrue(element.log.calledTwice);
                assert.isFalse(element._handleResponse.called);
                assert.isFalse(element._sendEvent.called);

                done();
              }, 20);
            });
          });
        });
      });
    </script>
  </body>
</html>
